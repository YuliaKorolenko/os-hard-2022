# os-hard-2022

### 1.Определение операционной системы. Отличие между ОС и ядром ОС. Базовые понятия и концепции ОС. Общая архитектура ОС.

2.Системные вызовы. Особенности параметризации системных вызовов.

3.Режимы (modes) исполнения в ОС. Пространства памяти в ОС.

4.Монолитное и микро-ядро ОС — различия. Модульная структура ядра ОС.

5.Реализации мульти-обработки в ОС. Различие между кооперативным и вытесняющей (preemptive) мульти-обработкой. Кооперативные и вытесняющие ядра (на примере Линукса). Асимметричная и симметричная мульти-обработка (Asymmetric / symmetric multi-processing). Масштабирование ядра ОС по процессорам.

6.Общая структура кода ядра Линукса.

7.Драйверы устройств в архитектуре Линукса.

8.Управление процессами в ОС. Процессы и потоки. Переключение контекста и миграция задач по ядрам процесссора. Контекст процесса. Доступ к текущему процессу. Блокирование и пробуждение. Вытеснение задач в терминах контекста процесса. Системный вызов clone().

9.Пространства имен и контейнеры.

10.Прерывания (Interrupts). Исключительные ситуации (exceptions). Аппаратная концепция прерываний. Программируемый контроллер прерываний. Обработка прерываний в Линуксе. Контекст прерывания. Отложенные действия (deferrable actions). Мягкие запросы на прерывания (Soft IRQ). Тасклеты (Tasklets). Рабочие очереди и таймеры.

11.Что такое управление памятью (memory management). Адресные пространства памяти — физическое и виртуальное. Таблицы трансляции виртуальных адресов. Контексты исполнения. Стеки пользовательского кода, кода ядра и кода прерываний. Страничная организация памяти и вытеснение страниц на диск.

12.Виртуальные и физические адреса. Устройство управления памятью (MMU). Буфера кэширования трансляции адресов (TLB). Адресные пространства на примере архитектуры ARM. Количество бит в адресе и деления адресов. Линейное отображение адресов. Нелинейное (произвольное) отображение адресов. Фиксированное отображение линейных адресов. Временное/быстрое отображение адресов (страницы в ядре). Постоянное отображение адресов.

13.Управление физической памятью. Зоны памяти. Неоднородный и однородный доступ к памяти. Кэш страниц в файловом доступе. Выделение физической памяти. kmalloc() & kfree(). Buddy-алгоритм выделения памяти.

14.Подход к SLAB выделению маленьких фрагментов памяти. Реализация SLAB. Кэши и SLAB.

15.Управление виртуальной памятью. Анонимная память (анонимное отображение памяти). Переиспользование (reclaim) памяти. Дефрагментация (Compaction) памяти. Обработка нехватки памяти (Out Of Memory Killer). Обработка обращения к отсутствующей странице (page fault). Типы/виды page fault. Влияние page fault на производительность.

16.Виртуальная файловая система и управление блочным вводом-выводом.

17.Абстракции файловой системы. Пример простой файловой системы (структура на диске). Операции файловой системы. Кэширование структур данных файловой системы.

18.Синхронизация — основные идеи и проблемы. Проблема состояния гонки (race condition). Как избегать состояния гонки. Атомарные операции. Спинлоки. Когерентность кэша в многопроцессорных системах. Протоколы когерентности кэша. Вытеснение используемых данных кэша (cache trashing). Синхронизация доступа к данным из контекста процесса и контекста прерывания. Мьютексы. Данные доступа на одном ядре (per CPU data). Упорядочивание доступа к памяти и барьеры. Чтение-копирование-обновление (Read-Copy-Update на примере списка).

19.Санитайзеры программ. Санитайзеры от Гугла. Санитайзеры EFENCE, KFENCE. Санитайзер KASAN. Теневая память в KASAN. Красные зоны в KASAN.

 ***20.Сетевая функциональность — история и концепции. TCP/IP. Семейство протоколов в TCP/IP. Протокол ARP. Сетевой стек — диаграмма и уровни. Единицы данных в сетевых протоколах. Блок-схема: Передача — прием данных в сети. Сетевые устройства. IP сервисы: роутинг. Сокеты. Пример использования сокетов для клиент-сервер программ. Сетевой стэк в Линуксе.***

***21.Планирование ресурсов в ОС. Планировщик процессов. Типы планировщиков (по горизонту планирования). Диспетчер процессора/процессов. FIFO планировщик. Метрики планирования в мобильной ОС.***

***22.Абстракции/концепции планирования. Абстракция/концепция аппаратуры/»железа»/устройства для планирования. Абстракция/концепция задачи/процесса для планирования.***

***23.История планировщиков в ядре Линукс. Планировщик CFS. Планировщик процессоров/процессов и формулы потребления энергии. Потребление энергии процессором/памятью. Абстракции управления потреблением энергии.***

***24.Что такое DVFS, зачем оно нужно. Архитектура big.LITTLE в контексте планирования процессов. EAS — что это такое, основные принципы. Отслеживание нагрузки для планирования процессов. EAS PELT/WALT. C & P, CC & PC состояния процессора. Управление P состояниями со стороны ОС. Масштибирование производительности в ядре Линукс. Управление частотами в ядре Линукс. Что такое CPUFreq, CPUIdle и гувернеры.***

***25.Распределенные системы. Оверлейные сети. Понятие middleware. ОС и middleware. Цели дизайна распределенной ОС. Ошибочные предположения в дизайне распределенной системы. Высокопроизводительные распределенные системы. Кластерные архитектуры. Grid-архитектуры. Облачные архитектуры. Проникующие системы (pervasive systems). Вездесущие (Ubiquitous) системы.***

***26.Мобильные ad hoc системы. Концепции архитектуры распределенных систем. Архитектурные стили для распределенных систем. Объектные архитектуры. Распределенные и удаленные обьекты. Ресурсно-ориентированные архитектуры. Архитектура Издатель-Подписчик. Структурированные peer-to-peer системы. Неструктурированные peer-to-peer системы: обмен сообщениями. Иерархические peer-to-peer системы.***

27.Основы программирования для мобильной ОС. Что такое ADB и как им пользоваться. Измерение производительности приложения в инструкциях и циклах. Что такое perf и как им пользоваться.



## Лекция 9 (Билет 20)
____________
Сетевой стек

История и концепции
---

1.В 1962 Пол Баран описал военную инфраструктуру(сеть), которая должна была выдержать ядерный удар.

2.В 1967 рассмотрел в статье ситуацию о том, что датаграммы (кусочки) приходят в разном порядке. И как собрать сообщение из этих датаграмм? Нужно пронумеровать их, и знать количество датаграмм.

3.В 1970 Выложили стать про первую военную сеть ARPANET.

4.В 1973 была сделана первая сеть, которая обеспечивала полььзовательским приложениям надежную связь между компьютерами. Cyclade. Аналог TCP.

5. В 1981 DARPA(какая-то военная организация) опубликовала первую спецификацию Internet. Сообщение кроме разбиения на пакеты и datagram, они могут разбиваться еще на другие кусочки. Кода мы посылает большой пакет, меньше энергии, но больше вероятность, что пакет потеряется и его нужно будет отправлять еще раз. Если 10 маленьких пакетов, то потеряется например 1, мы его дошлем и по задержке будет намного эффективнее.
6. 1999 NAT, в локальной сети несколько устройств могут разделять один публичный адрес, тогда пространство адресов становится намного больше.
7. . 2015 Публикация рекомендации об очередности передачи пакетов.

СЕТЬ - система взаимосвязанных устройств, которые могут передавать информацию, делится ресурсами (принтеры, файлы, приложения). Каждое устройство имеет свой IP адрес, с помощью которого может посылать и получать сообщения, используя TCP/IP протокол(набор правил).

TCP - Transmission Control Protocol(Протокол управления передачей)
обмен данными меджу приложениями и сетью
если пакет был утерян, то по протоколу он будет послан еще раз

UDP - User Datagram Protocol
приложение должно само следить за потерянными пакетами, поэтому обеспечивает более быструю передачу

IP - Internet Protocol(интернет протокол)
обмен данными между компьютерами

DHCP - с роутерами

HTTP - браузеры

HTTPS - более безопасное взаимодействие с браузерами

FTP - файлы скачивать

NTP -  синхронизировать часы

SSL - безопасный обмен данными

TCP/IP
---

Определяют, как разбивать на пакеты, как они адресуются, как получать и разбирать. Они очень устойчивы и так как есть избыточность связи, то даже во время катастрофы будет работать.

IP адресс (192.68.20.50) <- адрес версии 4, 4ехбайтный.
TCP/IP V6 использует 128 бита. 2 последние байта остаются для локальный устройств. TCP/IP помогает получить локальному устройству адрес в сети.

Доменное имя - (www.itmo-global.com) всегда отправляется на DNS сервер, и там хранится соответсвие между всеми такими доменными именами и TCP/IP адресами. Обратно присылается числовой адрес. Потом начинается работа.

![image](https://user-images.githubusercontent.com/79725120/213421503-9a7e953f-3409-4b1e-a2b4-45d0717d7b56.png)

ARP (Address resolution protocol)
---

преобразует 32битный адрес в физический адрес(MAC адрес 48 бит, который есть у каждого устройства, с помощью его можно отследить твоё устройство, не передается в пакетах, но используется в сетевом стеке)

В роутере есть запись о соответсвии mac и tcp

есть несколько подходов
1. табличный
2. хэширование
3. обменом сообщениями


Сетевой стек в ядре линукс
---

Состоит из 5 слоёв.
![image](https://user-images.githubusercontent.com/79725120/213424274-7be17742-7eb5-45d5-8383-9ae5134c11c3.png)

1. Приложение. Через system call обращаемся к ядру. Приложение вызывет socket API.
3. В ядре есть транспортный уровень, на нем выбираем свой нужный протокол и данные. Тут рабираваются на пакеты. Тут добавляется TCP заголовок.
4. Следующий сетевой уровень знает, что происходит во внешней сети. И в зависимости от ее характеристик он может либо объединять пакеты, или наоборот разбивать их. Тут добавляется IP заголовок. 
5. Data Link, выравнивает фрагменты, делает их понятными для аппаратуры. Тут добавляется frame заголовок. Отправляет сетевой карте драйвера запрос об отправлении frame, которые лежат в очереди.
6. Драйвера этих устройств <- Физический уровень. Берет из очереди отправки пакетов через DMA
и отправляет frame через физическую сетевую карту. Прямой доступ к памяти (англ. direct memory access, DMA) — режим обмена данными между устройствами компьютера или же между устройством и основной памятью,

![image](https://user-images.githubusercontent.com/79725120/213426209-c33894c3-4ab5-41a0-ab81-a3d2fb5e4930.png)

![image](https://user-images.githubusercontent.com/79725120/213428849-dfe52ae6-5114-4911-bf6a-c543baf990b0.png)

![image](https://user-images.githubusercontent.com/79725120/213429085-e27eca08-d9f2-4b10-82a7-66be92342c81.png)

TCP пакеты 
UDP datagram делится на фрагменты, а фрагменты упакованы в frame

Сетевые устройства
---

gateway - компьютер, который соединяет локальную сеть с интернетом.
repeaters - усиливают сигнал, передают дальше, чтобы сигнал не затухал.
bridges - может свзять несколько локальных сетей, работают на уровне frame, таким способом уменьшается нагрузка а сеть.

Routing
---

Пакет данных перемещается от источника к месту назначения с помощью router.
• Router отвечает за правильную адресацию в зависимости от объема трафика,
ошибки в сети или других параметров
Routing table кэширует адреса устройств.
Когда IP получает пакет от протокола более высокого уровня, такого как TCP или UDP,
в таблице маршрутизации ищется маршрут, наиболее близкий к пункту назначения.
• От наиболее специфичного к наименее специфичному маршруту идет следующий порядок:
• Маршрут, соответствующий IP-адресу назначения (маршрут хоста).
• Маршрут, который соответствует идентификатору сети IP-адреса назначения (сетевой
маршрут).
• Маршрут по умолчанию.
• Если соответствующий маршрут не найден, IP отбрасывает пакет.

IP services
----

Fragmentation, timeout, options

Fragmentation - возможность деления на более маленткие части

timeout - ограничение на количество узлов, которые может посетить пакет

options - можно установить требования при посылки, например отследить узлы посылки

Socket
----

Сокет — это конечная точка канал связи, используемый программой для передачи данных туда и обратно локально или через Интернет.

![image](https://user-images.githubusercontent.com/79725120/213431729-8cd76ab4-e8c7-429c-b627-b964b588a4b2.png)

![image](https://user-images.githubusercontent.com/79725120/213431822-61b5b11b-88bb-4394-bf5f-f244df441926.png)
  
Сетевой стек в Линуксе
---
  
  ![image](https://user-images.githubusercontent.com/79725120/213433410-c2da8749-0f28-49cf-bc95-0efdecc3c6bf.png)


## Лекция 10
______
Распределенные системы. Оверлейные сети. Понятие middleware. ОС и middleware. Цели дизайна распределенной ОС. Ошибочные предположения в дизайне распределенной системы. Высокопроизводительные распределенные системы. Кластерные архитектуры. Grid-архитектуры. Облачные архитектуры. Проникующие системы (pervasive systems). Вездесущие (Ubiquitous) системы.

Распределенные системы - набор автономных независимых элементов, которые для пользователя образуют цельную систему, они не видят ее структуры. Нет условий для частей системы, они могут быть высокопроизводительный. Также нет условий для связей астей. Изначально распределенную систему придумали для обмена сообщений(они могут быть сколь угодно большими). Потом обнаружилось, что на распределенный системах вычисления работают намного бытсрее.

Централизованная система - одна компонента, отличие в том, что части не могут работать по одиночке. Компьютер, телефон не являются распределенной системой.

Проблемы при организации распределенный систем
___________

1. отсутсвует общий глобальный временной механизм. Подключение к вай-фай работает в периодическом режиме, но создается впечатление, что он работает постоянно. история про apple, инженеры придумали, как можно максимальное количество устройств с одинаковой частотой бахнуть и это было наиболее энергоэффективно.
2. как упрявлять членством узлом во множеству, нужно реализовать процедуру регистрации. Есть открытые или закрытые(например, банкоские системы). Механизм аутентификации.

Оверлейные сети
----

Узел оверлейной сети — это программный процесс, оснащенный списком другихпроцессы, которым он может напрямую отправлять сообщения.
• Затем передача сообщений осуществляется по каналам TCP/IP или UDP.
(sockets). Также могут быть доступны средства более высокого уровня и более эффективные.

Обычно существует два типа оверлейных сетей:
1. Структурированное наложение: каждый узел имеет четко определенный набор соседей, с кем он может общаться. Например, узлы
организованы в виде дерева или логического кольца.
2. Неструктурированное наложение: каждый узел имеет ряд ссылок на
случайно выбранные другие узлы.
• Узлы в оверлейной сети всегда должны быть подключены
• всегда существует канал связи, позволяющий любым двум узлам маршрутизировать сообщения от одного к другому.
Пример: (P2P).

Middleware - еще один уровень программного обеспечения, который находится между ос и приложением(еще один уровень поверх ядра).
![image](https://user-images.githubusercontent.com/79725120/213441619-d9814705-7f3c-4738-a1a7-d234b4d74113.png)

Сетевой стек раньше был middleware, но потом ушел в ядро. 

Middleware & OS
Промежуточное ПО — это менеджер вычислений, хранения и сетевых ресурсов. Предлагая приложения для эффективного совместного использования и развертывания этих ресурсов в распределенной системе
Наряду с управлением ресурсами он предлагает услуги, которые также можно найти в большинстве ОС, в том числе:
• Средства для связи между приложениями.
• Охранные сервисы.
• Бухгалтерские сервисы.
• Маскировка и восстановление после сбоев.

Типичные мидлвэир сервисы
----

communication - удаленный вызов процедурю. Вызывающий процесс упаковывает операцию, этот пакет передается в ядро. Потом пакет передается в нужный процесс.
transaction - целостное действие, которое мы просим выполнить у другого процесса, либо получаем ответ, либо получаетм ничего.
serve composition - машап (информация из разных источников) в одном месте
reability - сообщение гарантированно будет послано одному из узлов

Цели дизайна распределенной ОС
----

1. Поддержка для совместного пользования ресурсами TCP - хорошая продвижка, общий протокол
2. Сделать незаметным факт распределенности. 
Репликация - есть сервис ютуба, как сделать быстрый доступ. Например, сделать дубликаты на локальные сервера.
Польностью прозрачными нельзя сделать все аспекты. 
![image](https://user-images.githubusercontent.com/79725120/213446524-464b35da-3f66-4057-9499-fda6253ebb74.png)
Можно сделать более понятным, что существует непрозрачность.
3. Открытость
Совместимость, компонуемость и расширяемость
• определять сервисы через интерфейсы, т.е. использование языка определения интерфейса (IDL)
• необходимость изменения распределенной системы часто вызвана компонентом,не обеспечивает оптимальную политику для конкретного пользователя или приложения
• разделение между политикой и механизмом
4. Маштабируемость
Когда распределенная система может увеличиваться и уменьшаться. scalable - вставляем в сревер диски большего объема scalout - ставим рядом еще один сервер.
Можем увеличивать географический охват
Администрированная масштабироемость -  это система, которой легко управлять даже если он охватывает множество независимых административных организаций.
5. Производительность
latency - интервал времени, можем замерить с помощью пинга
throughtput - гигабайты в секунду, скорость передачи данных
6. Надежность
Определяется вероятностью поломки
Можно обеспечить за счет избыточности.
7. Безопасность
Защита от дудос атак, от утечке данных
9. конкурентность, управляемость, разнородность

Проблемы с распределенной системы 
Network, nodes, SW are reliable
Не надо рассчитывать на надежность, система скорее всего перестанет работать, если слрмается какая-то его часть.
Network, nodes, SW are secure
Не нужно рассчитывать на безопасность, нам рассказывали про то что у интеля есть возможность отключить все процессоры.
Network, nodes, SW are homogeneous
Если мы хотим при поломке заменить
The topology does not change
Если перенести сервер, то все сломается
Latency is zero
не всегда
Bandwidth is infinite
Transport cost is zero
one administrator


Виды систем
----

Cluster computing
есть главный компьютер, он соединяется по обычной сети, локальные узлы по локальной сети
![image](https://user-images.githubusercontent.com/79725120/213449867-99fe144c-ad23-4d3f-85b5-9cfb32332b8d.png)

Grid
----

![image](https://user-images.githubusercontent.com/79725120/213449989-5b9333f8-089a-42a1-b049-638c2cfcee74.png)
Ресурсы из разных организаций объединяются, чтобы позволить сотрудничество группы людей из разных учреждений, образуя объединение систем.

Cloud 
----
![image](https://user-images.githubusercontent.com/79725120/213450327-24aa117b-87f3-4507-a7d8-0811c7b3dedf.png)

Аппаратное обеспечение: Нижний уровень формируется средствами управления необходимым аппаратным обеспечением:
процессоры, маршрутизаторы, а также системы питания и охлаждения. Обычно это реализуется в центрах обработки данных
и содержит ресурсы, которые клиенты обычно никогда не видят напрямую. • Инфраструктура. Это важный уровень, формирующий основу для большинства платформ облачных вычислений.
Он использует методы виртуализации, чтобы предоставить клиентам инфраструктуру, состоящую из виртуальных
хранения и вычислительных ресурсов. Действительно, все не так, как кажется: облачные вычисления развиваются вокруг
выделение и управление виртуальными устройствами хранения и виртуальными серверами. • Платформа: разработчику приложения предлагается специфичный для поставщика API, который включает вызовы для загрузки
и выполнение программы в облаке этого поставщика. В некотором смысле это сопоставимо с семейством Unix exec.
системных вызовов, которые принимают исполняемый файл в качестве параметра и передают его операционной системе для обработки.
казнен. Как и операционные системы, уровень платформы обеспечивает абстракции более высокого уровня для
хранилище
• . • Приложение. На этом уровне запускаются фактические приложения, которые предлагаются пользователям для дальнейшей настройки.
Хорошо известные примеры включают те, которые можно найти в офисных пакетах (текстовые процессоры, приложения для работы с электронными таблицами,
приложения для презентаций и так далее). Важно понимать, что эти приложения снова
выполняется в облаке поставщика. Как и прежде, их можно сравнить с традиционной сюитой
приложения, поставляемые при установке операционной системы.


Проникающие системы - проникает в наше окружение
----
Например система умного дома. Есть сенсоры и актуаторы(пылесос, кондиционеры)

Вездесущие системы
----
нельзя выключить, например спутниковая система, рассчитывающая геолокацию. С ними можно взаимодействовать неявным образом. Например, хочу включить сбор частоты сердца. Не требует вмешательства человека

Ad hoc системы
----
Например 2 телефона могут соединиться без использования датацентров.



### Лекция 11
Мобильные ad hoc системы. Концепции архитектуры распределенных систем. Архитектурные стили для распределенных систем. Объектные архитектуры. Распределенные и удаленные обьекты. Ресурсно-ориентированные архитектуры. Архитектура Издатель-Подписчик. Структурированные peer-to-peer системы. Неструктурированные peer-to-peer системы: обмен сообщениями. Иерархические peer-to-peer системы.

Мобильные ad hoc системы
----
Проникающая системы, 2 устройства можно объединить и обмениваться файлами. Нельзя сделать такое с большим количеством устройств, функциональность ограничена. Так как устройства перемещается, то оно может переместится настолько далеко, что выпадет из системы

Свойства:
1. Положение может менятся со временем
2. Устройства разного типа(пульт управления, что угодно).
3. Вмешательсво человека не требуется для настройки.
4. роутеры, все статические узлы не используются, так как, как правило, неустойчивы, поскольку узлы на пути маршрутизации могут легко выйти из диапазона соседа, что делает путь недействительным.
5. Такая система не используют заранее установленную инфраструктуру(роутеры, точки доступа)
6.  Тогда каждый узел участвует в маршрутизации, каждое устройство "роутер".

2 принципа
1. Если узлу нужно передать другому, то он может передать всех. Либо нужному, либо тому, кто может
2. Когда промежуточный узел получает сообщение, хранит полученное сообщение до тех пор, пока не встретится с другим узлом, которому он сможет его передать. Узел становится временным носителем сообщения.

Концепции архитектуры распределенных систем
Распределенные системы часто представляют собой сложные части программного обеспечения,
компоненты по определению рассредоточены по нескольким машинам. Чтобы справиться с их сложностью, крайне важно, чтобы эти системы были организованные. Организация распределенных систем в основном связана с программным обеспечением компоненты, из которых состоит система.
• Архитектура программного обеспечения

Компонента - модуль, единица трансляции, которую можно заменить. Приложение как компонента может быть перезапущена на ходу. Также хорошо, чтобы была реализована возможность, в которой компонента бы не работала и ничего не сломалось бы.

Коннектор - механизм, обеспечивает связь компонент.

Архитектурные стили для распределенных систем
----

1. Слоеная архитектура (Layered architectures)
2. Делается в терминах объектов(Object-based architectures)
3. ресурсы ( Resource-centered architectures)
4. события (Event-based (Publish-Subscribe) architectures)

Layered architectures
----

![image](https://user-images.githubusercontent.com/79725120/213586723-2766164d-a4e3-4527-9110-d8316b82bae0.png)

а) Строгая иерархия слоев
б) Нестрогая
с) Можно делать вызовы из верхнего в нижний и наоборот(upcalls)

Объектные архитектуры
----
Состоят из объектов разного уровня сложности в нужном порядке. 

![image](https://user-images.githubusercontent.com/79725120/213587099-06b0f89f-99c0-4231-ae9b-aaaab5fd6491.png)

Распределенные и удаленные обьекты
----

А что если объекты расположены на разных машинах. Помогают proxy sceleton
![image](https://user-images.githubusercontent.com/79725120/213587486-ffb64f26-1770-4ca3-b8fa-7ba22b26fcb3.png)

На клиентской машине создается proxy, кусок куда с таким же интерфейсом, как и у объекта с удаленной машины. Если Обращаемся к нему, то идем в скелетон на серверной машине и он уже вызывает нужный метод. А программе кажется, что мы просто вызвали объект.


![image](https://user-images.githubusercontent.com/79725120/213587870-e04d451a-b4b6-48ea-9f4f-aedb425ad02a.png)

Нужно понять, что такое враперы и брокеры

Ресурсно-ориентированные архитектуры
----

Есть возможность для удаленных приложений пользоваться архитектурами. Есть 4 операции PUT POST GET DELETE. У всех сервисов одинаковый интерфейс.

Архитектура Издатель-Подписчик
----

![image](https://user-images.githubusercontent.com/79725120/213588634-007497bf-1236-44df-92ff-3f5d571283e5.png)

Есть разнообразные компоненты, которые взаимодействуют друг с другом и общаются с помощью событий.
События 2 типов
1) Публикование
2) Подписка

Когда публикуется, подписываемая компонента должна быть активна в варианте а
В варианте б есть место, где хранятся все сообщения.

Детали:
Подписываться можно на интервал значений, или на одно.

Процесс, который занимается переносом сообщений, он может пинговать всех, а может иметь хэш- таблицу с подписчиками.

Также у сообщения может быть срок жизни, после которого он умирает.

Структурированные peer-to-peer системы
---- 
Можно поддерживать какую-то таблицу, которая будет поддерживать список подписчиков.

![image](https://user-images.githubusercontent.com/79725120/213589580-794c3d4b-72a8-4491-836d-9ba2dd8199ea.png)
![image](https://user-images.githubusercontent.com/79725120/213589782-0a4ab372-2497-4c77-9b91-15ffa8169d01.png)
избранные узлы соединены друг с другом, отвечают за все узлы, которые меньше них, промежуточные узлы могут добавлятся или удалятся


Неструктурированные peer-to-peer системы: обмен сообщениями
----
Вероятность наличия ребра между двумя узлами одинаковы. Когда какой-то узел присоединяется, ему нужно связаться с каким-то известным узлом, например к днс-серверу. Нет гарантии, что узлы будут жить, и как будут присоединяться.

Иерархические peer-to-peer системы.
----
Есть избранные узлы.
В новых системах поиск соответствующих элементов данных может стать проблематичным по мере роста сети.
Причина этой проблемы с масштабируемостью проста: поскольку не существует детерминированного способа маршрутизации запроса поиска к конкретному элементу данных, по сути, единственный метод, к которому может прибегнуть узел, — это поиск запроса с помощью флуда или случайное блуждание по сети.

В качестве альтернативы многие одноранговые системы предлагают использовать специальные узлы, поддерживающие индекс.
элементов данных. Существуют и другие ситуации, в которых отказ от симметричной природы одноранговых систем является целесообразным.
разумный. Рассмотрим сотрудничество узлов, которые предлагают ресурсы друг другу.
• Что необходимо, так это способ выяснить, где лучше всего хранить документы. В этом случае, используя брокера
который собирает данные об использовании и доступности ресурсов

![image](https://user-images.githubusercontent.com/79725120/213590277-60a95089-745a-44f7-99da-e9170efc689e.png)
пример иерархической системы, но не структурированной, потому что к любому избранному узлу могут подключаться любое количество обычных узлов.

## Лекция 12
21.Планирование ресурсов в ОС. Планировщик процессов. Типы планировщиков (по горизонту планирования). Диспетчер процессора/процессов. FIFO планировщик. Метрики планирования в мобильной ОС.

• Планирование CPU
• Планирование ввода-вывода
• Сетевое планирование
• Планирование памяти
• Планирование заданий (общий термин, относящийся к мейнфреймам, исторический

Датацентры потребляют очень много энергии. Зеленая повестка обманывает

Планирование ресурсов в ос - работа различных алгоритмов, которые ограниченное количество ресурсов распределяют по приложениям.

Когда данные читаются, приложение ничего не делает на процессоре, разумно отдать это время процессорное другому приложению.

Планирование выполняется планировщиками sheduler. Есть много планировщиков, например ввода-вывода. Намного проще разрабатывать отдельные планировщики по методы разделяй и властвуй. Однако если они не знают друг про друга, то они работают намного менее эффективно. были попытки сделать один глобальный планировщик, но до сих пор в ос планировщики специализированы(фукнкц разделена)

Цели
----
1. максимизация скорости вычисления
2. минимизация задержек
3. максимизировать справедливость распределения(либо поровну, либо делить так, что наиболее важная получала больше ресурсов)
4. минимизировать затрату батарейки

Часто цели конфликтуют

Ряд абстракиий планирования
----

Дисциплина планирования 
----

Часто планировщик выбирает несколько сценариев в зависимости от поведения пользователя. В одном случае алгоритм пытается минимизировать задержки, в другом случае минимизировать расход батареи. Например, когда мы в телефоне включаем режим экономии, то у нас по сути включается другой планировщик. И некоторые задачи будут выполняться например с большими интервалами.

Планирование ресурсов
----
несколько подходов
1. как используются устройства, планирование процессов
2. либо планирование задач

Планирование процессов
----
Еще одна группа алгоритмов, которые решают, в какой момент времени, какой процесс будет работать и какие задачи выполнять.
Планировщик процессов может останавливать процессы. Прием вытеснения из памяти процесса.
Процессы зависят от пользовательского ввода, железа и тд. Поэтому при планировании важно собирать статистику о работе приложения, сбор помогает существенно.

Тогда можем классифицировать приложения:
1. CPU bound - узкое место процессор, например вычисление матриц, вычисление числа пи
2. memory bound - опять же матрицы
3. IO bound - обработка баз данных, ввод вывод на диск
4. network bound - браузер

Типы планировщиков (по горизонту планирования)
----
1. Долгосрочные ( сервера)
2.  Среднесрочные
3.  Краткосрочные (мобильный телефон)

Долгосрочные планировщики
----

Планируют как правило такие операции, которые используют или очень много ввода-вывода, или очень много вычислений. Долг планировщики затощены на то, чтобы предугадывать, сколько задачам нужно времени ввода-вывода

Среднесрочные
----

Смесь между двумя. Оптимизированы, чтобы память каких-то приложений вытеснять на диск, а потом записывать. Если приложение какое-то время неактивно или низкий приоритет, или часто падают странички, если приложение занимает много памяти. 

Краткосрочные
----

Частота планирования существенно выше, следовательно время планирования нижу, чтобы операция чаще и быстро могла совершаться, милисекунды. Сбор почти никогда не применяется. Вариант выгоднее, это когда данные загружеются, отправляются на сервера, на них обучается нейронка, а потом загружается в телефоны опять.

Диспетчер - часть планировщика, работает в ядре
----

Диспетчер — это алгоритм, который передает управление ЦП процессу, выбранному краткосрочным планировщик. Происходит переключение контеста, сохраняется состояние процесса, загружает процесс, который надо загрузить. Передает на точку программы, с какого момента надо начать программу. Оно должно происходить быстро. Так как во время переключения проццесор и ядра процесссора ничего не делают. В айфонах почти все время работает 4 потока, в то время как на андроиде 100, поэтому планировка происходит проще и раскладывание по 4 ядрам тоже.

FIFO планировщик - First in, first out
----

Просто по сути очередь, не самый умный. В операционных системах не используется, но в некоторых приложениях - да. 
Например есть 8 потоков, одна очередь, тут нам надо задуматься о параллельности, например с мьютексами, но это не очень высоко в происзводительности. Если считаем, что порядок не очень важен, то мы можем завести 8 очередей, в которые потоки-исполнители складывают информацию, а поток потребитель забирает. 

Если каждому процессу, который сложили в очередь дать определенное время, за которое он должен отработать, то тогда каждый процесс через определенное назначенное время попробует отработаться. Круто

Если вводим понятие приоритета, то можно с большим приоритетом складывать в начало.

![image](https://user-images.githubusercontent.com/79725120/213691207-07cee459-9b03-40b8-8f21-b31ee468260d.png)


Метрики планирования в мобильной ОС
----

1)IPC - instructions per cycle

раньше проццесор был тем лучше, чем больше у него частота, но она мало говорит. Нужно количество испольненных инструкций за один цикл. 

IPC зависит от многих факторов: количества ядер ЦП, частоты ядер ЦП, количества, конвейеры ядра ЦП, планирование инструкций по порядку и не по порядку (спекулятивное) ЦП, задержка памяти, кеши SoC, алгоритм планирования ОС для многозадачности. ОТ программы и от компилятора, так как он может выстраивать их в параллельные штуки

Как мы можем выполнить 2 задачи за такт? Если у нас есть несколько конвееров для выполнения, на каждом выбираем инструкцию, они могут никак не зависеть друг от друга, например одна читает какую-то информацию, другая вычисляет что-либо, поэтому выполняем параллельно, так как в программах много последовательных инструкций, не связанных друг с другом.

Конвееры специализированные, одни для логических операций, другие для арифметических, третьи для даблов.

 2)DPC - Dynamic power consumption
 
• Статическое энергопотребление (мощность, потребляемая аппаратным обеспечением без выполнения задач) выходит за рамки нашего интереса
• DPC напрямую связан с разрядкой батареи в мобильных устройствах, разрядкой мощности центра обработки данных
• DPC измеряется в ваттах (джоулях в секунду, другими словами - производная работы по времени)
• DPC напрямую зависит от количества циклов ядра ЦП, затраченных на выполнение задачи, а также от мощности потребление другими устройствами, например. энергонезависимая память, сеть и т. д.
• Более высокий показатель IPC означает, что больше инструкций может быть выполнено при том же или более низком DPC.

Минимизация производственного цикла – классическая метрика в планировании.
----

Что может сделать планировщик мобильной ос?
Может быстренько собрать статистику о прерываниях, об их времени работы. И исходя из него распределяются задачи по потокам.

***Билет 22*** Абстракции/концепции планирования. Абстракция/концепция аппаратуры/»железа»/устройства для планирования. Абстракция/концепция задачи/процесса для планирования.

Абстракции/концепции планирования
----

1)Статическое - информация о приложении заранее известна, оно всегда вполняет последовательные действия, поэтому что-либо планировать для него легко.
2)Динамическое - мы только сможем оценить вероятность какого-то действия
3) Preemptive and non-preemptive scheduling - мы можем останавливать/убивать приложения, или нет. Более выгоден вариант с убийством.
4) Hard real-time and soft (non-) real-time scheduling - реальное время, значит до мы должны делать действия до дедлайна.
5) Partitioned and global scheduling
Разделенное - есть ядра у процессора, у каждого своя очредеь, мы ее выстраиваем, передаем каждому ядру свою задачку. 
6) Миграция статических задач — разделение задач осуществляется разработчиками,  снимается с планировщика немножко работы. (перед выполнением): некоторые задачи выделяются только одному ядру, в то время как другие
выделено более чем одному ядр
7) Dynamic workload balance – run-time migration of tasks ( разделеине задач в рантайме, ядра не обязаны быть из одного кластера)
8) Кластерное планирование, ядра разделены на кластеры. Каждый кластер планирует свои задачи независимо

![image](https://user-images.githubusercontent.com/79725120/213696091-f7c63b2f-4516-4fdf-9727-017641f628b0.png)
![image](https://user-images.githubusercontent.com/79725120/213696122-4d724ecb-d2cc-4e72-a46e-2adbf0288329.png)

![image](https://user-images.githubusercontent.com/79725120/213697074-d95b0909-c64a-42b6-a690-8f257453adfd.png)


Большое приложение уже разбито на маленькие задачи

Абстракция/концепция аппаратуры/»железа»/устройства для планирования
----
В зависимости от процессора планируем
![image](https://user-images.githubusercontent.com/79725120/213698691-9cf9d609-861b-4d23-a182-7ee297e39267.png)
Тут показан один из вариантов, когда есть хайповые большие проццесоры, которые делают более затратные операции, умеют выполнять не по порядку и менее хайповые.
Каждый кластер работает на независимой частоте,а все ядра в кластере работают на одинаковой. У каждого процессора свой кэш, у каждого кластера свой кеш. И это все связано через 128 битную шину.
1) 

Абстракция/концепция задачи/процесса для планирования
----
• новые задачи могут быть добавлены в любое время, старые задачи могут быть удалены в любое время
• каждая задача может быть запущена в произвольное время
• у каждой задачи могут быть требования к реагированию на внешние события (например, в пользовательском интерфейсе) • Установите T из |T| задачи, индексированные как t[1..|T|]: T = {t[1],…t[|T|]}
![image](https://user-images.githubusercontent.com/79725120/213704419-3ed9428f-9b15-4718-8b89-1a9cd0d2a66e.png)


Кэши могут быть запланированы на задчи и задачи на кэши.

## Лекция 13

***Билет 23.***.История планировщиков в ядре Линукс. Планировщик CFS. Планировщик процессоров/процессов и формулы потребления энергии. Потребление энергии процессором/памятью. Абстракции управления потреблением энергии.

***Билет 24***.Что такое DVFS, зачем оно нужно. Архитектура big.LITTLE в контексте планирования процессов. EAS — что это такое, основные принципы. Отслеживание нагрузки для планирования процессов. EAS PELT/WALT. C & P, CC & PC состояния процессора. Управление P состояниями со стороны ОС. Масштибирование производительности в ядре Линукс. Управление частотами в ядре Линукс. Что такое CPUFreq, CPUIdle и гувернеры.

1. очень простой планировщик на основе циклической очереди (Round-Robin)
2. Linux 2.4: планировщик O(n)
 Разделить процессорное время на эпохи. В каждой эпохе каждая задача может выполняться до своего кванта времени. Если задача не использует весь свой квант времени, то планировщик добавляет половину оставшийся временной отрезок, чтобы позволить ему выполняться дольше в следующей эпохе.
3. Linux 2.6.0 — Linux 2.6.22: планировщик O(1)
Каждому процессу дается фиксированный квант времени, после чего он вытесняется и
перемещен в просроченный массив. После того, как все задачи из активного массива исчерпали свой квант времени и
были перемещены в массив с истекшим сроком действия, происходит переключение массива. Поскольку доступ к массивам осуществляется только через указатель, переключение между ними происходит максимально быстро.
поменять местами два указателя. Этот переключатель делает активный массив новым пустым с истекшим сроком действия.
массив, в то время как массив с истекшим сроком действия становится активным массивом
4. Linux 2.6.23 (2007 г.): полностью честный планировщик. BFS (2009 г.) как альтернатива CFS
6. Linux/Android (2013+): начато обсуждение EAS.
7. Android (2017 г.): планировщик ядра 4.4–4.9 Energy Aware.
8. Linux 5.x (2022 г.):пдгодит для гетерогенных процессоров EAS это скедулер

Планировщик CFS
----

Используется красно-черное дерево. Задача либо крайнем левом, либо в крайнем правом. Сортируем по тому, насколько задача использовала процессор. Чем меньше занимала, тем больше приоритет.

Планировщик процессоров/процессов и формулы потребления энергии.
----

Если например задача требует много вычислительных ресурсов, то нужно ее испольнять на наиболее энергозатратном ядре. И наоборот. И по-разному использовать батарейку.

Чем выше частота, тем больше тратится энергии.

тут опять про биг литтл кластер
![image](https://user-images.githubusercontent.com/79725120/213864685-7479ac0b-a8f8-44cc-b4f6-317e189171ba.png)

Мобильные устройства получают энергию, необходимую для работы, от батарей, емкость которых ограничена.
по размеру устройства.
• Способность управлять энергопотреблением требует хорошего понимания того, где и как используется энергия.
• Расширение функциональности современных смартфонов увеличивает нагрузку на срок службы батареи и увеличивает потребность в эффективном управлении.

![image](https://user-images.githubusercontent.com/79725120/213864764-fb36c4e3-71c1-4522-8db3-e939a5d5b0df.png)

Формулы, которые использует планировщик
----

мощность = сила тока * напряжение
энергия = мощность * время
батарейка (5000 мили ампер) = сила тока * время * напряжение - время, которое есть в батарейках
мощность( динамическая) = частота * емкость * напряжене в квадрате + статическая мощность(мощность короткого замыкания + мощность утечки)

Напряжение и частота всегда изменяются вместе

Потребление энергии процессором/памятью.
----

Потребляемая мощность зависит от частоты, на каждый цикл(колебание) одна и та же мощность, но в зависимости от того сколько циклов в секунду изменяется кол-во потребляемой мощности.

Зачем планировать, как работает процессоры, так как например камера потребляет в 3 раза больше энергии. Камера - эпизодически. А проццессор работает всегда.

![image](https://user-images.githubusercontent.com/79725120/213865013-ec3d133b-4c8c-409b-9416-418b11132193.png)

Dynamic Voltage and Frequency Scaling
---
 Совместное изменения напряжения и частоты. Если изменить частоту, не меняя напряжения, то с телефоном произодет беда(кирпич). Функция, которой пользуется планировщик. 
 
Используется практически во всем современном компьютерном оборудовании для максимального энергосбережения.

Отслеживает рабочую нагрузку, определяет правильные настройки напряжения и тактовой частоты и соответствующим образом настраивает оборудование.

Например, неиспользуемый смартфон должен вернуться в режим пониженного энергопотребления, исключая помехи от
приложения. 

Для мультимедиа требуется больше энергии, поэтому устройство переходит в режим более высокого энергопотребления и выделяет больше тепла. во время более тяжелой обработки, такой как видео и игры. 

Если бы не DVFS, многим устройствам с пассивным охлаждением потребовалось бы активное охлаждение. Однако, шум, объем и потребляемая мощность, необходимые для активного охлаждения, делают его непрактичным для небольших устройства. 

DVFS помогает поддерживать рабочие параметры при повышенной мобильности.

![image](https://user-images.githubusercontent.com/79725120/213865475-b66b9329-4bff-4d86-b8ea-ec7fd04d1cfb.png)

Dynamic Power Management (DPM) to manage power in core idle state (состояние, в котором потребляется мало энергии) - not in our area of interes. f state - formale state (обычное), s(си) state (состояние сна)


Абстракции управления потреблением энергии.
----

Может оказаться, что процессор слишком быстро вычисляет данные, и данные из памяти не успевают вытаскиваться -> тратится много энергии, можно понизить частоту.

![image](https://user-images.githubusercontent.com/79725120/213865621-d21b89af-5625-4088-a202-50067a811ae1.png)

чето типо теперь после понижения на память потратится только 2 такта, хз почему





 
