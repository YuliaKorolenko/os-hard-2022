# os-hard-2022

### 1.Определение операционной системы. Отличие между ОС и ядром ОС. Базовые понятия и концепции ОС. Общая архитектура ОС.

2.Системные вызовы. Особенности параметризации системных вызовов.

3.Режимы (modes) исполнения в ОС. Пространства памяти в ОС.

4.Монолитное и микро-ядро ОС — различия. Модульная структура ядра ОС.

5.Реализации мульти-обработки в ОС. Различие между кооперативным и вытесняющей (preemptive) мульти-обработкой. Кооперативные и вытесняющие ядра (на примере Линукса). Асимметричная и симметричная мульти-обработка (Asymmetric / symmetric multi-processing). Масштабирование ядра ОС по процессорам.

6.Общая структура кода ядра Линукса.

7.Драйверы устройств в архитектуре Линукса.

8.Управление процессами в ОС. Процессы и потоки. Переключение контекста и миграция задач по ядрам процесссора. Контекст процесса. Доступ к текущему процессу. Блокирование и пробуждение. Вытеснение задач в терминах контекста процесса. Системный вызов clone().

9.Пространства имен и контейнеры.

10.Прерывания (Interrupts). Исключительные ситуации (exceptions). Аппаратная концепция прерываний. Программируемый контроллер прерываний. Обработка прерываний в Линуксе. Контекст прерывания. Отложенные действия (deferrable actions). Мягкие запросы на прерывания (Soft IRQ). Тасклеты (Tasklets). Рабочие очереди и таймеры.

11.Что такое управление памятью (memory management). Адресные пространства памяти — физическое и виртуальное. Таблицы трансляции виртуальных адресов. Контексты исполнения. Стеки пользовательского кода, кода яядра и кода прерываний. Страничная организация памяти и вытеснение страниц на диск.

Виртуальные и физические адреса. Устройство управления памятью (MMU). Буфера кэширования трансляции адресов (TLB). Адресные пространства на примере архитектуры ARM. Количество бит в адресе и деления адресов. Линейное отображение адресов. Нелинейное (произвольное) отображение адресов. Фиксированное отображение линейных адресов. Временное/быстрое отображение адресов (страницы в ядре). Постоянное отображение адресов.

Управление физической памятью. Зоны памяти. Неоднородный и однородный доступ к памяти. Кэш страниц в файловом доступе. Выделение физической памяти. kmalloc() & kfree(). Buddy-алгоритм выделения памяти.

Подход к SLAB выделению маленьких фрагментов памяти. Реализация SLAB. Кэши и SLAB.

Управление виртуальной памятью. Анонимная память (анонимное отображение памяти). Переиспользование (reclaim) памяти. Дефрагментация (Compaction) памяти. Обработка нехватки памяти (Out Of Memory Killer). Обработка обращения к отсутствующей странице (page fault). Типы/виды page fault. Влияние page fault на производительность.

Виртуальная файловая система и управление блочным вводом-выводом.

Абстракции файловой системы. Пример простой файловой системы (структура на диске). Операции файловой системы. Кэширование структур данных файловой системы.

Синхронизация — основные идеи и проблемы. Проблема состояния гонки (race condition). Как избегать состояния гонки. Атомарные операции. Спинлоки. Когерентность кэша в многопроцессорных системах. Протоколы когерентности кэша. Вытеснение используемых данных кэша (cache trashing). Синхронизация доступа к данным из контекста процесса и контекста прерывания. Мьютексы. Данные доступа на одном ядре (per CPU data). Упорядочивание доступа к памяти и барьеры. Чтение-копирование-обновление (Read-Copy-Update на примере списка).

Санитайзеры программ. Санитайзеры от Гугла. Санитайзеры EFENCE, KFENCE. Санитайзер KASAN. Теневая память в KASAN. Красные зоны в KASAN.

Сетевая функциональность — история и концепции. TCP/IP. Семейство протоколов в TCP/IP. Протокол ARP. Сетефой стек — диаграмма и уровни. Единицы данных в сетевых протоколах. Блок-схема: Передача — прием данных в сети. Сетевые устройства. IP сервисы: роутинг. Сокеты. Пример использования сокетов для клиент-сервер программ. Сетевой стэк в Линуксе.

Планирование ресурсов в ОС. Планировщик процессов. Типы планировщиков (по горизонту планирования). Диспетчер процессора/процессов. FIFO планировщик. Метрики планирования в мобильной ОС.

Абстракции/концепции планирования. Абстракция/концепция аппаратуры/»железа»/устройства для планирования. Абстракция/концепция задачи/процесса для планирования.

История планировщиков в ядре Линукс. Планировщик CFS. Планировщик процессоров/процессов и формулы потребления энергии. Потребление энергии процессором/памятью. Абстракции управления потреблением энергии.

Что такое DVFS, зачем оно нужно. Архитектура big.LITTLE в контексте планирования процессов. EAS — что это такое, основные принципы. Отслеживание нагрузки для планирования процессов. EAS PELT/WALT. C & P, CC & PC состояния процессора. Управление P состояниями со стороны ОС. Масштибирование производительности в ядре Линукс. Управление частотами в ядре Линукс. Что такое CPUFreq, CPUIdle и гувернеры.

Распределенные системы. Оверлейные сети. Понятие middleware. ОС и middleware. Цели дизайна распределенной ОС. Ошибочные предположения в дизайне распределенной системы. Высокопроизводительные распределенные системы. Кластерные архитектуры. Grid-архитектуры. Облачные архитектуры. Проникующие системы (pervasive systems). Вездесущие (Ubiquitous) системы.

Мобильные ad hoc системы. Концепции архитектуры распределенных систем. Архитектурные стили для распределенных систем. Объектные архитектуры. Распределенные и удаленные обьекты. Ресурсно-ориентированные архитектуры. Архитектура Издатель-Подписчик. Структурированные peer-to-peer системы. Неструктурированные peer-to-peer системы: обмен сообщениями. Иерархические peer-to-peer системы.

Основы программирования для мобильной ОС. Что такое ADB и как им пользоваться. Измерение производительности приложения в инструкциях и циклах. Что такое perf и как им пользоваться.



### Лекция 9
____________
Сетевой стек

История

1.В 1962 Пол Баран описал военную инфраструктуру(сеть), которая должна была выдержать ядерный удар.

2.В 1967 рассмотрел в статье ситуацию о том, что датаграммы (кусочки) приходят в разном порядке. И как собрать сообщение из этих датаграмм? Нужно пронумеровать их, и знать количество датаграмм.

3.В 1970 Выложили стать про первую военную сеть ARPANET.

4.В 1973 была сделана первая сеть, которая обеспечивала полььзовательским приложениям надежную связь между компьютерами. Cyclade. Аналог TCP

5. В 1981 DARPA(какая-то военная организация) опубликовала первую спецификацию Internet. Сообщение кроме разбиения на пакеты и datagram, они могут разбиваться еще на другие кусочки. Кода мы посылает большой пакет, меньше энергии, но больше вероятность, что пакет потеряется и его нужно будет отправлять еще раз. Если 10 маленьких пакетов, то потеряется например 1, мы его дошлем и по задержке будет намного эффективнее.
6. 1999 NAT, в локальной сети несколько устройств могут разделять один публичный адрес, тогда пространство адресов становится намного больше.
7. . 2015 Публикация рекомендации об очередности передачи пакетов.

СЕТЬ - система взаимосвязанных устройств, которые могут передавать информацию, делится ресурсами (принтеры, файлы, приложения). Каждое устройство имеет свой IP адрес, с помощью которого может посылать и получать сообщения, используя TCP/IP протокол(набор правил).

TCP - Transmission Control Protocol(Протокол управления передачей)
обмен данными меджу приложениями и сетью
если пакет был утерян, то по протоколу он будет послан еще раз

UDP - User Datagram Protocol
приложение должно само следить за потерянными пакетами, поэтому обеспечивает более быструю передачу

IP - Internet Protocol(интернет протокол)
обмен данными между компьютерами

DHCP - с роутерами

HTTP - браузеры

HTTPS - более безопасное взаимодействие с браузерами

FTP - файлы скачивать

NTP -  синхронизировать часы

SSL - безопасный обмен данными

Определяют, как разбивать на пакеты, как они адресуются, как получать и разбирать. Они очень устойчивы и так как есть избыточность связи, то даже во время катастрофы будет работать.


IP адресс (192.68.20.50) <- адрес версии 4, 4ехбайтный.
TCP/IP V6 использует 64 бита. 2 последние байта остаются для локальный устройств. TCP/IP помогает получить локальному устройству адрес в сети.

Доменное имя - (www.itmo-global.com) всегда отправляется на DNS сервер, и там хранится соответсвие между всеми такими доменными именами и TCP/IP адресами. Обратно присылается числовой адрес. Потом начинается работа.

![image](https://user-images.githubusercontent.com/79725120/213421503-9a7e953f-3409-4b1e-a2b4-45d0717d7b56.png)

ARP (Address resolution protocol)
преобразует 32битный адрес в физический адрес(MAC адрес 48 бит, который есть у каждого устройства, с помощью его можно отследить твоё устройство, не передается в пакетах, но используется в сетевом стеке)

В роутере есть запись о соответсвии mac и tcp

есть несколько подходов
1. табличный
2. хэширование
3. обменом сообщениями


Сетевой стек в ядре линукс

Состоит из 5 слоёв.
![image](https://user-images.githubusercontent.com/79725120/213424274-7be17742-7eb5-45d5-8383-9ae5134c11c3.png)

1. Приложение. Через system call обращаемся к ядру
3. В ядре есть транспортный уровень, на нем выбираем свой нужный протокол и данные. Тут рабираваются на пакеты
4. Следующий сетевой уровень знает, что происходит во внешней сети. И в зависимости от ее характеристик он может либо объединять пакеты, или наоборот разбивать их.
5. Data Link, выравнивает фрагменты, делает их понятными для аппаратуры 
6. Драйвера этих устройств <- Физический уровень





