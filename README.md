# os-hard-2022

### 1.Определение операционной системы. Отличие между ОС и ядром ОС. Базовые понятия и концепции ОС. Общая архитектура ОС.

2.Системные вызовы. Особенности параметризации системных вызовов.

3.Режимы (modes) исполнения в ОС. Пространства памяти в ОС.

4.Монолитное и микро-ядро ОС — различия. Модульная структура ядра ОС.

5.Реализации мульти-обработки в ОС. Различие между кооперативным и вытесняющей (preemptive) мульти-обработкой. Кооперативные и вытесняющие ядра (на примере Линукса). Асимметричная и симметричная мульти-обработка (Asymmetric / symmetric multi-processing). Масштабирование ядра ОС по процессорам.

6.Общая структура кода ядра Линукса.

7.Драйверы устройств в архитектуре Линукса.

8.Управление процессами в ОС. Процессы и потоки. Переключение контекста и миграция задач по ядрам процесссора. Контекст процесса. Доступ к текущему процессу. Блокирование и пробуждение. Вытеснение задач в терминах контекста процесса. Системный вызов clone().

9.Пространства имен и контейнеры.

10.Прерывания (Interrupts). Исключительные ситуации (exceptions). Аппаратная концепция прерываний. Программируемый контроллер прерываний. Обработка прерываний в Линуксе. Контекст прерывания. Отложенные действия (deferrable actions). Мягкие запросы на прерывания (Soft IRQ). Тасклеты (Tasklets). Рабочие очереди и таймеры.

11.Что такое управление памятью (memory management). Адресные пространства памяти — физическое и виртуальное. Таблицы трансляции виртуальных адресов. Контексты исполнения. Стеки пользовательского кода, кода яядра и кода прерываний. Страничная организация памяти и вытеснение страниц на диск.

12.Виртуальные и физические адреса. Устройство управления памятью (MMU). Буфера кэширования трансляции адресов (TLB). Адресные пространства на примере архитектуры ARM. Количество бит в адресе и деления адресов. Линейное отображение адресов. Нелинейное (произвольное) отображение адресов. Фиксированное отображение линейных адресов. Временное/быстрое отображение адресов (страницы в ядре). Постоянное отображение адресов.

13.Управление физической памятью. Зоны памяти. Неоднородный и однородный доступ к памяти. Кэш страниц в файловом доступе. Выделение физической памяти. kmalloc() & kfree(). Buddy-алгоритм выделения памяти.

14.Подход к SLAB выделению маленьких фрагментов памяти. Реализация SLAB. Кэши и SLAB.

15.Управление виртуальной памятью. Анонимная память (анонимное отображение памяти). Переиспользование (reclaim) памяти. Дефрагментация (Compaction) памяти. Обработка нехватки памяти (Out Of Memory Killer). Обработка обращения к отсутствующей странице (page fault). Типы/виды page fault. Влияние page fault на производительность.

16.Виртуальная файловая система и управление блочным вводом-выводом.

17.Абстракции файловой системы. Пример простой файловой системы (структура на диске). Операции файловой системы. Кэширование структур данных файловой системы.

18.Синхронизация — основные идеи и проблемы. Проблема состояния гонки (race condition). Как избегать состояния гонки. Атомарные операции. Спинлоки. Когерентность кэша в многопроцессорных системах. Протоколы когерентности кэша. Вытеснение используемых данных кэша (cache trashing). Синхронизация доступа к данным из контекста процесса и контекста прерывания. Мьютексы. Данные доступа на одном ядре (per CPU data). Упорядочивание доступа к памяти и барьеры. Чтение-копирование-обновление (Read-Copy-Update на примере списка).

19.Санитайзеры программ. Санитайзеры от Гугла. Санитайзеры EFENCE, KFENCE. Санитайзер KASAN. Теневая память в KASAN. Красные зоны в KASAN.

<b>20<b>.Сетевая функциональность — история и концепции. TCP/IP. Семейство протоколов в TCP/IP. Протокол ARP. Сетевой стек — диаграмма и уровни. Единицы данных в сетевых протоколах. Блок-схема: Передача — прием данных в сети. Сетевые устройства. IP сервисы: роутинг. Сокеты. Пример использования сокетов для клиент-сервер программ. Сетевой стэк в Линуксе.

21.Планирование ресурсов в ОС. Планировщик процессов. Типы планировщиков (по горизонту планирования). Диспетчер процессора/процессов. FIFO планировщик. Метрики планирования в мобильной ОС.

22.Абстракции/концепции планирования. Абстракция/концепция аппаратуры/»железа»/устройства для планирования. Абстракция/концепция задачи/процесса для планирования.

23.История планировщиков в ядре Линукс. Планировщик CFS. Планировщик процессоров/процессов и формулы потребления энергии. Потребление энергии процессором/памятью. Абстракции управления потреблением энергии.

24.Что такое DVFS, зачем оно нужно. Архитектура big.LITTLE в контексте планирования процессов. EAS — что это такое, основные принципы. Отслеживание нагрузки для планирования процессов. EAS PELT/WALT. C & P, CC & PC состояния процессора. Управление P состояниями со стороны ОС. Масштибирование производительности в ядре Линукс. Управление частотами в ядре Линукс. Что такое CPUFreq, CPUIdle и гувернеры.

25.Распределенные системы. Оверлейные сети. Понятие middleware. ОС и middleware. Цели дизайна распределенной ОС. Ошибочные предположения в дизайне распределенной системы. Высокопроизводительные распределенные системы. Кластерные архитектуры. Grid-архитектуры. Облачные архитектуры. Проникующие системы (pervasive systems). Вездесущие (Ubiquitous) системы.

26.Мобильные ad hoc системы. Концепции архитектуры распределенных систем. Архитектурные стили для распределенных систем. Объектные архитектуры. Распределенные и удаленные обьекты. Ресурсно-ориентированные архитектуры. Архитектура Издатель-Подписчик. Структурированные peer-to-peer системы. Неструктурированные peer-to-peer системы: обмен сообщениями. Иерархические peer-to-peer системы.

27.Основы программирования для мобильной ОС. Что такое ADB и как им пользоваться. Измерение производительности приложения в инструкциях и циклах. Что такое perf и как им пользоваться.



## Лекция 9 (Билет 20)
____________
Сетевой стек

История и концепции
---

1.В 1962 Пол Баран описал военную инфраструктуру(сеть), которая должна была выдержать ядерный удар.

2.В 1967 рассмотрел в статье ситуацию о том, что датаграммы (кусочки) приходят в разном порядке. И как собрать сообщение из этих датаграмм? Нужно пронумеровать их, и знать количество датаграмм.

3.В 1970 Выложили стать про первую военную сеть ARPANET.

4.В 1973 была сделана первая сеть, которая обеспечивала полььзовательским приложениям надежную связь между компьютерами. Cyclade. Аналог TCP.

5. В 1981 DARPA(какая-то военная организация) опубликовала первую спецификацию Internet. Сообщение кроме разбиения на пакеты и datagram, они могут разбиваться еще на другие кусочки. Кода мы посылает большой пакет, меньше энергии, но больше вероятность, что пакет потеряется и его нужно будет отправлять еще раз. Если 10 маленьких пакетов, то потеряется например 1, мы его дошлем и по задержке будет намного эффективнее.
6. 1999 NAT, в локальной сети несколько устройств могут разделять один публичный адрес, тогда пространство адресов становится намного больше.
7. . 2015 Публикация рекомендации об очередности передачи пакетов.

СЕТЬ - система взаимосвязанных устройств, которые могут передавать информацию, делится ресурсами (принтеры, файлы, приложения). Каждое устройство имеет свой IP адрес, с помощью которого может посылать и получать сообщения, используя TCP/IP протокол(набор правил).

TCP - Transmission Control Protocol(Протокол управления передачей)
обмен данными меджу приложениями и сетью
если пакет был утерян, то по протоколу он будет послан еще раз

UDP - User Datagram Protocol
приложение должно само следить за потерянными пакетами, поэтому обеспечивает более быструю передачу

IP - Internet Protocol(интернет протокол)
обмен данными между компьютерами

DHCP - с роутерами

HTTP - браузеры

HTTPS - более безопасное взаимодействие с браузерами

FTP - файлы скачивать

NTP -  синхронизировать часы

SSL - безопасный обмен данными

TCP/IP
---

Определяют, как разбивать на пакеты, как они адресуются, как получать и разбирать. Они очень устойчивы и так как есть избыточность связи, то даже во время катастрофы будет работать.

IP адресс (192.68.20.50) <- адрес версии 4, 4ехбайтный.
TCP/IP V6 использует 64 бита. 2 последние байта остаются для локальный устройств. TCP/IP помогает получить локальному устройству адрес в сети.

Доменное имя - (www.itmo-global.com) всегда отправляется на DNS сервер, и там хранится соответсвие между всеми такими доменными именами и TCP/IP адресами. Обратно присылается числовой адрес. Потом начинается работа.

![image](https://user-images.githubusercontent.com/79725120/213421503-9a7e953f-3409-4b1e-a2b4-45d0717d7b56.png)

ARP (Address resolution protocol)
---

преобразует 32битный адрес в физический адрес(MAC адрес 48 бит, который есть у каждого устройства, с помощью его можно отследить твоё устройство, не передается в пакетах, но используется в сетевом стеке)

В роутере есть запись о соответсвии mac и tcp

есть несколько подходов
1. табличный
2. хэширование
3. обменом сообщениями


Сетевой стек в ядре линукс
---

Состоит из 5 слоёв.
![image](https://user-images.githubusercontent.com/79725120/213424274-7be17742-7eb5-45d5-8383-9ae5134c11c3.png)

1. Приложение. Через system call обращаемся к ядру. Приложение вызывет socket API.
3. В ядре есть транспортный уровень, на нем выбираем свой нужный протокол и данные. Тут рабираваются на пакеты. Тут добавляется TCP заголовок.
4. Следующий сетевой уровень знает, что происходит во внешней сети. И в зависимости от ее характеристик он может либо объединять пакеты, или наоборот разбивать их. Тут добавляется IP заголовок. 
5. Data Link, выравнивает фрагменты, делает их понятными для аппаратуры. Тут добавляется frame заголовок. Отправляет сетевой карте драйвера запрос об отправлении frame, которые лежат в очереди.
6. Драйвера этих устройств <- Физический уровень. Берет из очереди отправки пакетов через DMA
и отправляет frame через физическую сетевую карту. Прямой доступ к памяти (англ. direct memory access, DMA) — режим обмена данными между устройствами компьютера или же между устройством и основной памятью,

![image](https://user-images.githubusercontent.com/79725120/213426209-c33894c3-4ab5-41a0-ab81-a3d2fb5e4930.png)

![image](https://user-images.githubusercontent.com/79725120/213428849-dfe52ae6-5114-4911-bf6a-c543baf990b0.png)

![image](https://user-images.githubusercontent.com/79725120/213429085-e27eca08-d9f2-4b10-82a7-66be92342c81.png)

TCP пакеты 
UDP datagram делится на фрагменты, а фрагменты упакованы в frame

Сетевые устройства
---

gateway - компьютер, который соединяет локальную сеть с интернетом.
repeaters - усиливают сигнал, передают дальше, чтобы сигнал не затухал.
bridges - может свзять несколько локальных сетей, работают на уровне frame, таким способом уменьшается нагрузка а сеть.

Routing
---

Пакет данных перемещается от источника к месту назначения с помощью router.
• Router отвечает за правильную адресацию в зависимости от объема трафика,
ошибки в сети или других параметров
Routing table кэширует адреса устройств.
Когда IP получает пакет от протокола более высокого уровня, такого как TCP или UDP,
в таблице маршрутизации ищется маршрут, наиболее близкий к пункту назначения.
• От наиболее специфичного к наименее специфичному маршруту идет следующий порядок:
• Маршрут, соответствующий IP-адресу назначения (маршрут хоста).
• Маршрут, который соответствует идентификатору сети IP-адреса назначения (сетевой
маршрут).
• Маршрут по умолчанию.
• Если соответствующий маршрут не найден, IP отбрасывает пакет.

IP services
----

Fragmentation, timeout, options

Fragmentation - возможность деления на более маленткие части

timeout - ограничение на количество узлов, которые может посетить пакет

options - можно установить требования при посылки, например отследить узлы посылки

Socket
----

Сокет — это конечная точка канал связи, используемый программой для передачи данных туда и обратно локально или через Интернет.

![image](https://user-images.githubusercontent.com/79725120/213431729-8cd76ab4-e8c7-429c-b627-b964b588a4b2.png)

![image](https://user-images.githubusercontent.com/79725120/213431822-61b5b11b-88bb-4394-bf5f-f244df441926.png)
  
Сетевой стек в Линуксе
---
  
  ![image](https://user-images.githubusercontent.com/79725120/213433410-c2da8749-0f28-49cf-bc95-0efdecc3c6bf.png)



## Лекция 10












